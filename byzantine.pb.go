// Code generated by protoc-gen-go.
// source: byzantine.proto
// DO NOT EDIT!

/*
Package byzantine is a generated protocol buffer package.

It is generated from these files:
	byzantine.proto

It has these top-level messages:
	Publication
	PubResponse
	SubRequest
	ChainMAC
	ChainResponse
	EchoResponse
	ReadyResponse
*/
package byzantine

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Publication struct {
	PubType       uint32      `protobuf:"varint,1,opt,name=PubType" json:"PubType,omitempty"`
	PublisherID   uint64      `protobuf:"varint,2,opt,name=PublisherID" json:"PublisherID,omitempty"`
	PublicationID int64       `protobuf:"zigzag64,3,opt,name=PublicationID" json:"PublicationID,omitempty"`
	TopicID       uint64      `protobuf:"varint,4,opt,name=TopicID" json:"TopicID,omitempty"`
	BrokerID      uint64      `protobuf:"varint,5,opt,name=BrokerID" json:"BrokerID,omitempty"`
	Contents      [][]byte    `protobuf:"bytes,6,rep,name=Contents,proto3" json:"Contents,omitempty"`
	MAC           []byte      `protobuf:"bytes,7,opt,name=MAC,proto3" json:"MAC,omitempty"`
	ChainMACs     []*ChainMAC `protobuf:"bytes,8,rep,name=ChainMACs" json:"ChainMACs,omitempty"`
}

func (m *Publication) Reset()                    { *m = Publication{} }
func (m *Publication) String() string            { return proto.CompactTextString(m) }
func (*Publication) ProtoMessage()               {}
func (*Publication) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Publication) GetPubType() uint32 {
	if m != nil {
		return m.PubType
	}
	return 0
}

func (m *Publication) GetPublisherID() uint64 {
	if m != nil {
		return m.PublisherID
	}
	return 0
}

func (m *Publication) GetPublicationID() int64 {
	if m != nil {
		return m.PublicationID
	}
	return 0
}

func (m *Publication) GetTopicID() uint64 {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *Publication) GetBrokerID() uint64 {
	if m != nil {
		return m.BrokerID
	}
	return 0
}

func (m *Publication) GetContents() [][]byte {
	if m != nil {
		return m.Contents
	}
	return nil
}

func (m *Publication) GetMAC() []byte {
	if m != nil {
		return m.MAC
	}
	return nil
}

func (m *Publication) GetChainMACs() []*ChainMAC {
	if m != nil {
		return m.ChainMACs
	}
	return nil
}

type PubResponse struct {
	Success bool `protobuf:"varint,1,opt,name=Success" json:"Success,omitempty"`
}

func (m *PubResponse) Reset()                    { *m = PubResponse{} }
func (m *PubResponse) String() string            { return proto.CompactTextString(m) }
func (*PubResponse) ProtoMessage()               {}
func (*PubResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *PubResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type SubRequest struct {
	PublisherID uint64 `protobuf:"varint,1,opt,name=PublisherID" json:"PublisherID,omitempty"`
	BrokerID    uint64 `protobuf:"varint,2,opt,name=BrokerID" json:"BrokerID,omitempty"`
}

func (m *SubRequest) Reset()                    { *m = SubRequest{} }
func (m *SubRequest) String() string            { return proto.CompactTextString(m) }
func (*SubRequest) ProtoMessage()               {}
func (*SubRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SubRequest) GetPublisherID() uint64 {
	if m != nil {
		return m.PublisherID
	}
	return 0
}

func (m *SubRequest) GetBrokerID() uint64 {
	if m != nil {
		return m.BrokerID
	}
	return 0
}

type ChainMAC struct {
	From string `protobuf:"bytes,1,opt,name=From" json:"From,omitempty"`
	To   string `protobuf:"bytes,2,opt,name=To" json:"To,omitempty"`
	MAC  []byte `protobuf:"bytes,3,opt,name=MAC,proto3" json:"MAC,omitempty"`
}

func (m *ChainMAC) Reset()                    { *m = ChainMAC{} }
func (m *ChainMAC) String() string            { return proto.CompactTextString(m) }
func (*ChainMAC) ProtoMessage()               {}
func (*ChainMAC) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ChainMAC) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *ChainMAC) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *ChainMAC) GetMAC() []byte {
	if m != nil {
		return m.MAC
	}
	return nil
}

type ChainResponse struct {
	Valid bool `protobuf:"varint,1,opt,name=Valid" json:"Valid,omitempty"`
}

func (m *ChainResponse) Reset()                    { *m = ChainResponse{} }
func (m *ChainResponse) String() string            { return proto.CompactTextString(m) }
func (*ChainResponse) ProtoMessage()               {}
func (*ChainResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ChainResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

type EchoResponse struct {
	Hello bool `protobuf:"varint,1,opt,name=Hello" json:"Hello,omitempty"`
}

func (m *EchoResponse) Reset()                    { *m = EchoResponse{} }
func (m *EchoResponse) String() string            { return proto.CompactTextString(m) }
func (*EchoResponse) ProtoMessage()               {}
func (*EchoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *EchoResponse) GetHello() bool {
	if m != nil {
		return m.Hello
	}
	return false
}

type ReadyResponse struct {
	Ready bool `protobuf:"varint,1,opt,name=Ready" json:"Ready,omitempty"`
}

func (m *ReadyResponse) Reset()                    { *m = ReadyResponse{} }
func (m *ReadyResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadyResponse) ProtoMessage()               {}
func (*ReadyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ReadyResponse) GetReady() bool {
	if m != nil {
		return m.Ready
	}
	return false
}

func init() {
	proto.RegisterType((*Publication)(nil), "byzantine.Publication")
	proto.RegisterType((*PubResponse)(nil), "byzantine.PubResponse")
	proto.RegisterType((*SubRequest)(nil), "byzantine.SubRequest")
	proto.RegisterType((*ChainMAC)(nil), "byzantine.ChainMAC")
	proto.RegisterType((*ChainResponse)(nil), "byzantine.ChainResponse")
	proto.RegisterType((*EchoResponse)(nil), "byzantine.EchoResponse")
	proto.RegisterType((*ReadyResponse)(nil), "byzantine.ReadyResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for PubBroker service

type PubBrokerClient interface {
	Publish(ctx context.Context, in *Publication, opts ...grpc.CallOption) (*PubResponse, error)
}

type pubBrokerClient struct {
	cc *grpc.ClientConn
}

func NewPubBrokerClient(cc *grpc.ClientConn) PubBrokerClient {
	return &pubBrokerClient{cc}
}

func (c *pubBrokerClient) Publish(ctx context.Context, in *Publication, opts ...grpc.CallOption) (*PubResponse, error) {
	out := new(PubResponse)
	err := grpc.Invoke(ctx, "/byzantine.PubBroker/Publish", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for PubBroker service

type PubBrokerServer interface {
	Publish(context.Context, *Publication) (*PubResponse, error)
}

func RegisterPubBrokerServer(s *grpc.Server, srv PubBrokerServer) {
	s.RegisterService(&_PubBroker_serviceDesc, srv)
}

func _PubBroker_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Publication)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PubBrokerServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/byzantine.PubBroker/Publish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PubBrokerServer).Publish(ctx, req.(*Publication))
	}
	return interceptor(ctx, in, info, handler)
}

var _PubBroker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "byzantine.PubBroker",
	HandlerType: (*PubBrokerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Publish",
			Handler:    _PubBroker_Publish_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "byzantine.proto",
}

// Client API for SubBroker service

type SubBrokerClient interface {
	Subscribe(ctx context.Context, opts ...grpc.CallOption) (SubBroker_SubscribeClient, error)
}

type subBrokerClient struct {
	cc *grpc.ClientConn
}

func NewSubBrokerClient(cc *grpc.ClientConn) SubBrokerClient {
	return &subBrokerClient{cc}
}

func (c *subBrokerClient) Subscribe(ctx context.Context, opts ...grpc.CallOption) (SubBroker_SubscribeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SubBroker_serviceDesc.Streams[0], c.cc, "/byzantine.SubBroker/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &subBrokerSubscribeClient{stream}
	return x, nil
}

type SubBroker_SubscribeClient interface {
	Send(*SubRequest) error
	Recv() (*Publication, error)
	grpc.ClientStream
}

type subBrokerSubscribeClient struct {
	grpc.ClientStream
}

func (x *subBrokerSubscribeClient) Send(m *SubRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *subBrokerSubscribeClient) Recv() (*Publication, error) {
	m := new(Publication)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SubBroker service

type SubBrokerServer interface {
	Subscribe(SubBroker_SubscribeServer) error
}

func RegisterSubBrokerServer(s *grpc.Server, srv SubBrokerServer) {
	s.RegisterService(&_SubBroker_serviceDesc, srv)
}

func _SubBroker_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SubBrokerServer).Subscribe(&subBrokerSubscribeServer{stream})
}

type SubBroker_SubscribeServer interface {
	Send(*Publication) error
	Recv() (*SubRequest, error)
	grpc.ServerStream
}

type subBrokerSubscribeServer struct {
	grpc.ServerStream
}

func (x *subBrokerSubscribeServer) Send(m *Publication) error {
	return x.ServerStream.SendMsg(m)
}

func (x *subBrokerSubscribeServer) Recv() (*SubRequest, error) {
	m := new(SubRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SubBroker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "byzantine.SubBroker",
	HandlerType: (*SubBrokerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _SubBroker_Subscribe_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "byzantine.proto",
}

// Client API for InterBroker service

type InterBrokerClient interface {
	Echo(ctx context.Context, in *Publication, opts ...grpc.CallOption) (*EchoResponse, error)
	Ready(ctx context.Context, in *Publication, opts ...grpc.CallOption) (*ReadyResponse, error)
	Chain(ctx context.Context, in *Publication, opts ...grpc.CallOption) (*ChainResponse, error)
}

type interBrokerClient struct {
	cc *grpc.ClientConn
}

func NewInterBrokerClient(cc *grpc.ClientConn) InterBrokerClient {
	return &interBrokerClient{cc}
}

func (c *interBrokerClient) Echo(ctx context.Context, in *Publication, opts ...grpc.CallOption) (*EchoResponse, error) {
	out := new(EchoResponse)
	err := grpc.Invoke(ctx, "/byzantine.InterBroker/Echo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interBrokerClient) Ready(ctx context.Context, in *Publication, opts ...grpc.CallOption) (*ReadyResponse, error) {
	out := new(ReadyResponse)
	err := grpc.Invoke(ctx, "/byzantine.InterBroker/Ready", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interBrokerClient) Chain(ctx context.Context, in *Publication, opts ...grpc.CallOption) (*ChainResponse, error) {
	out := new(ChainResponse)
	err := grpc.Invoke(ctx, "/byzantine.InterBroker/Chain", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for InterBroker service

type InterBrokerServer interface {
	Echo(context.Context, *Publication) (*EchoResponse, error)
	Ready(context.Context, *Publication) (*ReadyResponse, error)
	Chain(context.Context, *Publication) (*ChainResponse, error)
}

func RegisterInterBrokerServer(s *grpc.Server, srv InterBrokerServer) {
	s.RegisterService(&_InterBroker_serviceDesc, srv)
}

func _InterBroker_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Publication)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterBrokerServer).Echo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/byzantine.InterBroker/Echo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterBrokerServer).Echo(ctx, req.(*Publication))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterBroker_Ready_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Publication)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterBrokerServer).Ready(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/byzantine.InterBroker/Ready",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterBrokerServer).Ready(ctx, req.(*Publication))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterBroker_Chain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Publication)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterBrokerServer).Chain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/byzantine.InterBroker/Chain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterBrokerServer).Chain(ctx, req.(*Publication))
	}
	return interceptor(ctx, in, info, handler)
}

var _InterBroker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "byzantine.InterBroker",
	HandlerType: (*InterBrokerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Echo",
			Handler:    _InterBroker_Echo_Handler,
		},
		{
			MethodName: "Ready",
			Handler:    _InterBroker_Ready_Handler,
		},
		{
			MethodName: "Chain",
			Handler:    _InterBroker_Chain_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "byzantine.proto",
}

func init() { proto.RegisterFile("byzantine.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 525 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0xc1, 0x8e, 0xd3, 0x30,
	0x14, 0xc4, 0x69, 0xbb, 0xdb, 0xbc, 0xb6, 0xb0, 0x18, 0x4a, 0xa3, 0x02, 0x52, 0x64, 0x2d, 0x22,
	0xea, 0x61, 0x03, 0xe5, 0x56, 0x2e, 0x2c, 0x2d, 0x88, 0x22, 0xad, 0x54, 0xb9, 0xd5, 0x8a, 0x23,
	0x49, 0xd6, 0xda, 0x46, 0x74, 0xe3, 0x10, 0x27, 0x87, 0x72, 0xe4, 0xc0, 0x0f, 0xf0, 0x69, 0xfc,
	0x02, 0x9f, 0xc0, 0x07, 0xa0, 0xbc, 0xd6, 0xa9, 0xbb, 0xa8, 0x12, 0x37, 0xcf, 0x78, 0x32, 0xcf,
	0x33, 0xb6, 0x02, 0xf7, 0xc2, 0xf5, 0xb7, 0x20, 0xc9, 0xe3, 0x44, 0x9c, 0xa5, 0x99, 0xcc, 0x25,
	0xb5, 0x2b, 0xa2, 0xff, 0xe4, 0x5a, 0xca, 0xeb, 0x95, 0xf0, 0x83, 0x34, 0xf6, 0x83, 0x24, 0x91,
	0x79, 0x90, 0xc7, 0x32, 0x51, 0x1b, 0x21, 0xfb, 0x61, 0x41, 0x6b, 0x56, 0x84, 0xab, 0x38, 0x42,
	0x9a, 0x3a, 0x70, 0x3c, 0x2b, 0xc2, 0xc5, 0x3a, 0x15, 0x0e, 0x71, 0x89, 0xd7, 0xe1, 0x1a, 0x52,
	0x77, 0x2b, 0x54, 0x4b, 0x91, 0x4d, 0x27, 0x8e, 0xe5, 0x12, 0xaf, 0xce, 0x4d, 0x8a, 0x9e, 0x42,
	0xc7, 0xb0, 0x9a, 0x4e, 0x9c, 0x9a, 0x4b, 0x3c, 0xca, 0xf7, 0xc9, 0x72, 0xc2, 0x42, 0xa6, 0x71,
	0x34, 0x9d, 0x38, 0x75, 0xf4, 0xd0, 0x90, 0xf6, 0xa1, 0xf9, 0x36, 0x93, 0x5f, 0xd0, 0xbe, 0x81,
	0x5b, 0x15, 0x2e, 0xf7, 0xc6, 0x32, 0xc9, 0x45, 0x92, 0x2b, 0xe7, 0xc8, 0xad, 0x79, 0x6d, 0x5e,
	0x61, 0x7a, 0x02, 0xb5, 0x8b, 0xf3, 0xb1, 0x73, 0xec, 0x12, 0xaf, 0xcd, 0xcb, 0x25, 0x7d, 0x09,
	0xf6, 0x78, 0x19, 0xc4, 0xc9, 0xc5, 0xf9, 0x58, 0x39, 0x4d, 0xb7, 0xe6, 0xb5, 0x86, 0x0f, 0xce,
	0x76, 0x1d, 0xe9, 0x3d, 0xbe, 0x53, 0xb1, 0xe7, 0x18, 0x8f, 0x0b, 0x95, 0xca, 0x44, 0x89, 0xf2,
	0x94, 0xf3, 0x22, 0x8a, 0x84, 0x52, 0xd8, 0x43, 0x93, 0x6b, 0xc8, 0x3e, 0x02, 0xcc, 0x4b, 0xe1,
	0xd7, 0x42, 0xa8, 0xfc, 0x76, 0x2b, 0xe4, 0xdf, 0x56, 0xcc, 0x54, 0xd6, 0x7e, 0x2a, 0xf6, 0x06,
	0x9a, 0xfa, 0x04, 0x94, 0x42, 0xfd, 0x7d, 0x26, 0x6f, 0xd0, 0xc2, 0xe6, 0xb8, 0xa6, 0x77, 0xc1,
	0x5a, 0x48, 0xfc, 0xca, 0xe6, 0xd6, 0x42, 0xea, 0xa4, 0xb5, 0x2a, 0x29, 0x7b, 0x06, 0x1d, 0x74,
	0xa8, 0x0e, 0xfe, 0x10, 0x1a, 0x97, 0xc1, 0x2a, 0xbe, 0xda, 0x1e, 0x7b, 0x03, 0xd8, 0x29, 0xb4,
	0xdf, 0x45, 0x4b, 0x69, 0xaa, 0x3e, 0x88, 0xd5, 0x4a, 0x6a, 0x15, 0x82, 0xd2, 0x8c, 0x8b, 0xe0,
	0x6a, 0x6d, 0xca, 0x90, 0xd0, 0x32, 0x04, 0x43, 0x01, 0xf6, 0xac, 0x08, 0x37, 0x21, 0xe8, 0x27,
	0x7c, 0x30, 0x65, 0x5a, 0xfa, 0xc8, 0xa8, 0xd8, 0xb8, 0xf3, 0xfe, 0x2d, 0x5e, 0xbb, 0xb3, 0xa7,
	0xdf, 0x7f, 0xfd, 0xfe, 0x69, 0xf5, 0x18, 0xf5, 0x53, 0xdd, 0x97, 0x5e, 0x8d, 0xc8, 0x60, 0x78,
	0x03, 0xf6, 0xbc, 0x1a, 0xf3, 0x19, 0x81, 0x8a, 0xb2, 0x38, 0x14, 0xb4, 0x6b, 0x18, 0xee, 0xee,
	0xa2, 0x7f, 0x60, 0x3e, 0x73, 0x71, 0x4e, 0x9f, 0x75, 0x7d, 0xa5, 0x2d, 0xb2, 0xdd, 0x72, 0x44,
	0x06, 0x1e, 0x79, 0x41, 0x86, 0x7f, 0x08, 0xb4, 0xa6, 0x49, 0x2e, 0xb2, 0xed, 0xc4, 0x19, 0xd4,
	0xcb, 0xca, 0x0e, 0xa6, 0xea, 0x19, 0xbc, 0xd9, 0x2d, 0xeb, 0xe1, 0xb8, 0xfb, 0xac, 0xed, 0x87,
	0xe8, 0xe4, 0x8b, 0x68, 0x29, 0x47, 0x64, 0x40, 0x2f, 0xb7, 0x6d, 0x1e, 0xb4, 0x74, 0x0c, 0x7e,
	0xef, 0x22, 0xd8, 0x63, 0xf4, 0xec, 0xb2, 0x13, 0xa3, 0xaa, 0xac, 0x54, 0x94, 0xbe, 0xaf, 0xa1,
	0x81, 0x6f, 0xe0, 0xbf, 0x7c, 0xf7, 0x5e, 0x0b, 0xbb, 0x13, 0x1e, 0xe1, 0x7f, 0xe0, 0xd5, 0xdf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0xb3, 0x66, 0x24, 0x37, 0x43, 0x04, 0x00, 0x00,
}
